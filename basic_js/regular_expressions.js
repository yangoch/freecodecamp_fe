// let petString = "James has a pet cat.";
// let petString = "James has a pet lion.";
// let petRegex = /dog|bird|cat|fish/; // Змініть цей рядок
// let result = petRegex.test(petString);

// console.log(result);

// ===>
// /ignorecase/i

// let myString = "freeCodeCamp";
// let fccRegex = /freecodecamp/i; // Змініть цей рядок
// let result = fccRegex.test(myString);

// console.log(result); //true

// ===>

// let extractStr = "Extract the word 'coding' from this string.";
// let codingRegex = /coding/; // Змініть цей рядок
// let result = extractStr.match(codingRegex); // Змініть цей рядок

// console.log(result);

// ===>

// Щоб знайти або вилучити шаблон більше одного разу, ви можете використати прапорець глобального пошуку: g.
// let twinkleStar = "Twinkle, twinkle, little star";
// let starRegex = /twinkle/gi; // Змініть цей рядок
// let result = twinkleStar.match(starRegex); // Змініть цей рядок

// console.log(result);

// ===>
// Допишіть регулярний вираз unRegex, щоб він збігався з рядками run, sun, fun, pun, nun та bun. Ваш регулярний вираз має використати байдужий символ.
// let exampleStr = "Let's have fun with regular expressions!";
// let unRegex = /.un/; // Змініть цей рядок
// let result = unRegex.test(exampleStr);

// console.log(result);

// ===>

// Використайте символьний клас до голосних (a, e, i, o, u) у регулярному виразі vowelRegex, щоб знайти всі голосні в рядку quoteSample.
// let quoteSample = "Beware of bugs in the above code; I have only proved it correct, not tried it.";
// let vowelRegex = /[aeiou]/gi; // Змініть цей рядок
// let result = quoteSample.match(vowelRegex); // Змініть цей рядок

// console.log(result);

// ===>

// Всередині набору символів можна визначити діапазон символів для пошуку збігів, використавши дефіс -.

// Наприклад, щоб знайти збіги літер нижнього регістру від a до e, використайте [a-e].

// let quoteSample = "The quick brown fox jumps over the lazy dog.";
// let alphabetRegex = /[a-z]/gi; // Змініть цей рядок
// let result = quoteSample.match(alphabetRegex); // Змініть цей рядок

// console.log(result);

// ===>

// Створіть регулярний вираз, який збігається з діапазоном літер від h до s та діапазоном чисел від 2 до 6. Не забудьте використати відповідні прапорці у регулярному виразі.

// let quoteSample = "Blueberry 3.141592653s are delicious.";
// let myRegex = /[h-s2-6]/ig; // Змініть цей рядок
// let result = quoteSample.match(myRegex); // Змініть цей рядок

// console.log(result);

// ===>

// Щоб створити негативний набір символів, поставте символ карет (^) після відкриття дужок та перед символами, для яких ви не хочете шукати збіги.

// Наприклад, /[^aeiou]/gi знайде збіги для всіх символів, що не є голосними. Зверніть увагу, що для таких символів як ., !, [, @, / і пробілів також будуть знайдені збіги: негативна група символів голосних виключає лише символи голосних.

// Створіть один регулярний вираз, що знаходить збіги для всіх символів, крім чисел та голосних. Не забудьте включити відповідні прапорці у регулярному виразі.

// let quoteSample = "3 blind mice.";
// let myRegex = /[^0-9aeiou]/ig; // Змініть цей рядок
// let result = quoteSample.match(myRegex); // Змініть цей рядок

// console.log(result);

// ===>

// Іноді потрібно знайти символ (або групу символів), які з’являються один чи більше разів поспіль. Це означає, що він зустрічається принаймні раз та може повторюватися.

// Можна використати символ +, щоб перевірити чи це так. Пам’ятайте, символ або шаблон мають бути послідовними. Тобто символ має повторюватися.

// Наприклад, /a+/g знайде один збіг в abc та поверне ["a"]. + також знайде один збіг в aabc та поверне ["aa"].

// Але якби він перевірив рядок abab, було б знайдено два збіги та повернено ["a", "a"], оскільки символи a не стоять поруч: між ними є символ b. Зрештою, оскільки в рядку bcd немає a, збігу не буде.

// Вам потрібно знайти збіги, коли літера s з’являється один чи більше разів у Mississippi. Напишіть регулярний вираз, що містить знак +.

// let difficultSpelling = "Mississippi";
// let myRegex = /s+/g; // Змініть цей рядок
// let result = difficultSpelling.match(myRegex);

// console.log(result);

// ===>

// У попередньому завданні ми використали +, щоб знайти символи, які зустрічаються один чи більше разів. Існує й варіант пошуку символів, які зустрічаються нуль чи більше разів.

// Для цього використовують зірочку: *.

// Для цього завдання chewieQuote було ініціалізовано як рядок Aaaaaaaaaaaaaaaarrrgh!. Створіть регулярний вираз chewieRegex, який використовує символ *, щоб збігтися з символом A у верхньому регістрі, за яким одразу стоїть нуль чи більше символів a у нижньому регістрі в chewieQuote. Ваш регулярний вираз не потребує прапорців чи символьних класів, а також не може збігатися з іншими цитатами.

// Змініть код лише під цим рядком
// let chewieQuote = "Let him have it. It's not wise to upset a Wookiee.";
// let chewieQuote = "Aaaaaaaaaaaaaaaarrrgh!";
// let chewieRegex = /Aa*/; // Змініть цей рядок
// // Змініть код лише над цим рядком

// let result = chewieQuote.match(chewieRegex);

// console.log(result);

// ===>

// Жадібний збіг знаходить найдовшу частину рядка, яка відповідає шаблону регулярного виразу та повертає його як збіг. Альтернативою є лінивий збіг, що знаходить найменшу частину рядка, яка відповідає шаблону регулярного виразу.

// Ви можете застосувати регулярний вираз /t[a-z]*i/ до рядка "titanic". Цей регулярний вираз фактично є шаблоном, який починається з t, закінчується на i та має кілька літер між ними.

// Регулярні вирази за замовчуванням «жадібні», тому збіг поверне ["titani"]. Він знаходить найбільший можливий підрядок, який відповідає шаблону.

// Однак ви можете використати символ ?, щоб змінити його на «лінивий» пошук. "titanic", зіставлений зі скоригованим регулярним виразом /t[a-z]*?i/ поверне ["ti"].

// let text = "<h1>Winter is coming</h1>";
// let myRegex = /<.*?>/; // Змініть цей рядок
// let result = text.match(myRegex);

// console.log(result)

// ===>

// Напишіть «жадібний» регулярний вираз, який знайде одного або більше злочинців серед групи інших людей. Злочинець позначений великою літерою C.

// let reCriminals = /C+/g; // Змініть цей рядок

// console.log("P1P5P4CCCcP2P6P3".match(reCriminals))
// console.log("P6P2P7P4P5CCCCCP3P1".match(reCriminals))
// console.log("P2P1P5P4CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCP".match(reCriminals));

// ===>

// Попередні завдання показали, що регулярні вирази можна використовувати для багатьох збігів. Їх також використовують для пошуку шаблонів у певному місці рядка.

// У попередньому завданні ви використали символ карет (^) всередині набору символів для того, щоб створити набір заперечних символів у вигляді [^thingsThatWillNotBeMatched]. За межами набору символів, карет використовують для пошуку шаблонів на початку рядка.

// let rickyAndCal = "Cal and Ricky both like racing.";
// let calRegex =  /^Cal/; // Змініть цей рядок
// let result = calRegex.test(rickyAndCal);

// console.log(result);

// ===>

// Ви можете виконати пошук по кінцях рядків, використовуючи символ долара $ у кінці регулярного виразу.

// let caboose = "The last car on a train is the caboose";
// let lastRegex = /caboose$/; // Змініть цей рядок
// let result = lastRegex.test(caboose);

// console.log(result);

// ===>

// Використовуючи символьні класи, ви знайшли всі літери алфавіту за допомогою [a-z]. Такий тип символьних класів настільки популярний, що для нього існує скорочення, хоча воно й містить декілька додаткових символів.

// Символьним класом, який дозволяє виконати найближчий збіг з алфавітом, є \w. Це скорочення дорівнює [A-Za-z0-9_]. Цей символьний клас відповідає великим і малим літерам та числам. Зверніть увагу, що цей символьний клас також містить знак підкреслення (_).

// let quoteSample = "The five boxing wizards jump quickly.";

// let longHand = /[A-Za-z0-9_]+/;
// let shortHand = /\w+/;

// let alphabetRegexV2 = /[a-z0-9]/gi; // Змініть цей рядок
// let alphabetRegexV2 = /\w/g; // Змініть цей рядок
// let result = quoteSample.match(alphabetRegexV2).length;

// console.log(result);

// ===>

// Ви вже дізналися, що можна використовувати скорочення для пошуку відповідності алфавітно-цифрового індикатора [A-Za-z0-9_], використовуючи \w. Звісно, вам може бути потрібно знайти протилежне до алфавітно-цифрового індикатора.

// Ви можете знайти протилежне значення функції \w з \W. Майте на увазі, що протилежний шаблон використовується з великою літерою. Це скорочення збігається з [^A-Za-z0-9_].

// let quoteSample = "The five boxing wizards jump quickly.";
// let nonAlphabetRegex = /\W/g; // Змініть цей рядок
// let result = quoteSample.match(nonAlphabetRegex).length;

// console.log(result);

// ===>

// Скороченням для пошуку цифрових символів є \d, з d у нижньому регістрі. Це дорівнює символьному класу [0-9], який шукає окремий символ, що є цифрою від 0 до 9.

// Використайте скорочений символьний клас \d, щоб підрахувати кількість цифрових символів у назвах фільмів. Числа прописом («шість» замість 6) не враховуються.

// let movieName = "2001: A Space Odyssey";
// let numRegex = /\d/g; // Змініть цей рядок
// let result = movieName.match(numRegex).length;

// console.log(result);


// Скороченням для пошуку нецифрових символів є \D. Це дорівнює символьному класу [^0-9], який шукає окремий символ, що не є цифрою від 0 до 9.

// let movieName = "2001: A Space Odyssey";
// let noNumRegex = /\D/g; // Змініть цей рядок
// let result = movieName.match(noNumRegex).length;

// console.log(result);

// ===> The Small Test 


// Вам потрібно перевірити всі імена користувачів у базі даних. Ось кілька простих правил, яких користувачі повинні дотримуватись при створенні імені користувача.

// Користувачі можуть використовувати лише алфавітно-цифрові символи.

// Числа повинні бути лише в кінці імені користувача. У кінці їх може бути нуль або більше. Ім'я користувача не повинно починатися з числа.

// Літери в імені користувача можуть бути нижнього та верхнього регістру.

// Імена користувачів повинні містити щонайменше два символи. Ім'я користувача з двох символів може містити лише символи літер алфавіту.



// let username = "JACK"; // true
// let username = "JackOfAllTrades"; // true
// =>
// let userCheck = /^[a-z]([0-9]{2,}|[a-z]+\d*)$/i; // Змініть цей рядок
// ^ - start of input
// [a-z] - first character is a letter
// [0-9]{2,} - ends with two or more numbers
// | - or
// [a-z]+ - has one or more letters next
// \d* - and ends with zero or more numbers
// $ - end of input
// i - ignore case of input
// =>

// =>
// let userCheck = /^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i;
// Code Explanation
// ^ - start of input
// [a-z] - first character is a letter
// [a-z]+ - following characters are letters
// \d*$ - input ends with 0 or more digits
// | - or
// ^[a-z] - first character is a letter
// \d\d+ - following characters are 2 or more digits
// $ - end of input
// =>

// let result = userCheck.test(username);

// console.log(result);





// ===>


// Завдання, які ми вже виконали, містять пошук збігів з літерами алфавіту та числами. Ви також можете шукати збіги з пробілами або проміжків між літерами.

// Ви можете шукати пробіли, використовуючи \s з літерою s нижнього регістру. Цей шаблон знайде збіги не лише із символами пробілу, але також символами повернення каретки, табуляції, розриву сторінки та нового рядка. Можете вважати, що це схоже на клас символів [ \r\t\f\n\v].


// let sample = "Whitespace is important in separating words";
// let countWhiteSpace = /\s/g; // Змініть цей рядок
// let result = sample.match(countWhiteSpace);


// console.log(result);


// ===>

// Пошук збігів із символами, що не є пробілами

// Ви дізналися, як шукати пробіли, використовуючи \s з літерою s нижнього регістру. Ви можете також шукати все, крім пробілів.

// Ви можете шукати символи, що не є пробілами, за допомогою \S з літерою s верхнього регістру. Цей шаблон не знайде збігів із символами пробілу, повернення каретки, табуляції, розриву сторінки та нового рядка. Можете вважати, що це схоже на клас символів [^ \r\t\f\n\v].

// let sample = "Whitespace is important in separating words";
// let countNonWhiteSpace = /\S/ig; // Змініть цей рядок
// let result = sample.match(countNonWhiteSpace);

// console.log(result.length);


// ===>

// Визначення найменшої та найбільшої кількості збігів

// Згадайте, що ми можете використати знак плюс +, щоб шукати один та більше знаків і зірочку *, щоб шукати нуль та більше знаків. Це зручно, але іноді потрібно знайти збіги для певного діапазону шаблонів.

// Ви можете визначити найменшу та найбільшу кількість шаблонів за допомогою специфікатора кількості. Специфікатори кількості використовуються з фігурними дужками ({ and }). У фігурні дужки ви ставите два числа: для найменшої та найбільшої кількості шаблонів.

// Наприклад, щоб знайти збіг лише для літери a, яка трапляється від 3 до 5 разів у рядку ah, ваш регулярний вираз має виглядати так: /a{3,5}h/.

// let ohStr = "Ohhh no";
// let ohStr = "Ohhhhh no";
// let ohRegex = /oh{3,6}\sno/ig; // Змініть цей рядок
// let result = ohRegex.test(ohStr);

// console.log(result);


// ===> 

// Визначення лише найменшої кількості збігів

// Ви можете визначити найменшу та найбільшу кількість шаблонів за допомогою специфікатора кількості, використовуючи фігурні дужки. Іноді вам потрібно визначити лише найменшу кількість шаблонів без верхньої межі.

// Щоб вказати лише найменшу кількість шаблонів, поставте після першого числа кому.

// Наприклад, щоб мати збіг лише з рядком hah з літерою a, що повторюється щонайменше 3 рази, регулярний вираз має бути таким: /ha{3,}h/.

// let haStr = "Hazzzzah";
// let haRegex = /haz{4,}ah/i; // Змініть цей рядок
// let result = haRegex.test(haStr);

// console.log(result);

// ===>

// Збережено! Код було збережено в локальному сховищі вашого браузера.
// Алгоритми JavaScript та структури даних
// Регулярні вирази
// Визначення точної кількості збігів
// Ви можете визначити найменшу та найбільшу кількість шаблонів за допомогою специфікатора кількості, використовуючи фігурні дужки. Іноді вам потрібна лише певна кількість збігів.

// Щоб вказати певну кількість шаблонів, просто поставте одне число у фігурні дужки.

// Наприклад, щоб мати збіг лише зі словом hah з літерою a, що повторюється 3 рази, регулярний вираз має бути таким: /ha{3}h/.


// let timStr = "Timmmmber";
// let timRegex = /tim{4}ber/i; // Змініть цей рядок
// let result = timRegex.test(timStr);

// console.log(result);


// ===>

// Пошук можливого символа

// Іноді у потрібних вам шаблонах можуть бути частини, які, можливо, не існують. Однак їх всеодно важливо пошукати.

// Ви можете вказати можливу наявність елемента знаком запитання ?. Таким чином ви зможете перевірити наявність попереднього елемента. Вважайте, що цей символ вказує на те, що елемент перед ним необов’язковий.

// Наприклад, в американській та британській англійській мові є незначні відмінності правопису, і ви можете скористатися знаком запитання, щоб відповідати обом системам написання.

// let favWord = "favorite";
// let favRegex = /favou?rite/; // Змініть цей рядок
// let result = favRegex.test(favWord);

// console.log(result);


// ===>

// Позитивне і негативне передбачення
// Lookaheads - це шаблони, які вказують JavaScript заглянути у ваш рядок заздалегідь, щоб перевірити наявність шаблонів далі. Це може бути корисно при пошуку декількох шаблонів на одному рядку.

// Існує два типи виглядів: позитивний огляд і негативний огляд.

// Позитивне передбачення шукатиме, щоб переконатися, що елемент у шаблоні пошуку є, але насправді не відповідатиме йому. Позитивне передбачення використовується як (?=...), де ... необхідна частина, яка не збігається.

// З іншого боку, негативне передбачення буде стежити за тим, щоб елемент в зразку пошуку був відсутній. Негативний огляд використовується як (?!...), де ... необхідний шаблон, який не збігається. Решта шаблону повертається, якщо немає негативного передбачення.

// let sampleWord = "astronaut12";
// let pwRegex = /(?=\w{6})(?=\w*\d{2,})/ig; // Змініть цей рядок
// let result = pwRegex.test(sampleWord);

// console.log(result);

// ===>


// Пошук змішаних груп символів

// Іноді потрібно перевірити групи символів за допомогою регулярного виразу. Для цього використовують дужки ().

// Якщо ви хочете знайти Penguin або Pumpkin в рядку, використайте регулярний вираз /P(engu|umpk)in/g.

// Після цього перевірте, чи бажані групи рядків знаходяться в тестовому рядку за допомогою методу test().

// let myString = "Eleanor Roosevelt";
// let myRegex = /(Franklin|Eleanor) (([A-Z]\.?|[A-Z][a-z]+) )?Roosevelt/; // Змініть цей рядок
// let result = myRegex.test(myString); // Змініть цей рядок

// console.log(result);

// ===>

// Повторне використання шаблонів за допомогою груп

// Припустімо, ви хочете знайти збіг для слова, що трапляється кілька разів, як у прикладі нижче.

// let repeatStr = "row row row your boat";
// Ви можете використати /row row row/, але що робити, якщо ви не знаєте, яке точно слово повторюється? Capture groups можна використовувати для пошуку повторюваних підрядків.

// Групи захоплення створюються за допомогою оточення візерунка регулярного виразу, що має бути зафіксованим в дужках. В такому разі ціль полягає у захваті слова, що складається зі алфавітно-цифрових символів, отже група захоплення має \w+ позначатися дужками: /(\w+)/.

// Підрядок, що відповідає групі зберігається до тимчасової "змінної", доступ до якої можна отримати у межах одного й того ж самого регулярного виразу за допомогою зворотнього слешу і номера групи захоплення (напр. \1). Групи захоплення автоматично нумеруються за порядком запуску (зліва направо), починаючи з 1.


// let repeatNum = "42 42 42 42";
// let reRegex = /^(\d+) \1 \1(?!.)/;
// let result = reRegex.test(repeatNum);

// console.log(result);


// ===> 

// Використання груп захоплення для пошуку та заміни

// Пошук корисний. Проте ви можете зробити пошук ще ефективнішим, коли він також змінюватиме (або замінюватиме) текст, для якого ви шукаєте збіг.

// Ви можете шукати і замінювати текст у рядку, застосовуючи .replace() до рядка. Першими вхідними даними для .replace() є регулярний вираз для шаблону, який ви хочете знайти. Другим параметром є рядок для заміни збігу або функції для виконання чогось.

// let str = "one two three";
// let fixRegex = /(\w+) (\w+) (\w+)/; // Змініть цей рядок
// let replaceText = "$3 $2 $1"; // Змініть цей рядок
// let result = str.replace(fixRegex, replaceText);

// console.log(result);


// ===>

// Видалення пробілу з початку та кінця

// Іноді пробіли присутні навколо рядка, коли вони там непотрібні. Типовою обробкою рядка є видалення пробілів на їхньому початку та кінці.

let hello = "   Hello, World!  ";
let wsRegex = /^\s+|\s+$/g; // Змініть цей рядок
let result = hello.replace(wsRegex, ""); // Змініть цей рядок

console.log(hello.length);
console.log(result);
console.log(result.length);